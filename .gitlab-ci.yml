stages:
  - test
  - coverage
  - release
  - publish

# Global variables and cache
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

cache:
  paths:
    - .cache/pip
    - venv/

# ------------- Base Templates -------------

.test-template: &test-template
  stage: test
  before_script:
    - python -m pip install --upgrade pip setuptools wheel
    - python -m pip install -e .[test]
  script:
    - python -c "import gwsim; print('gwsim version:', gwsim.__version__)"
    - gwsim --help
    - export COVERAGE_FILE=.coverage.$CI_JOB_NAME
    - pytest
  artifacts:
    when: always
    paths:
      - .coverage.*
      - test-results.xml
      - coverage.xml
    reports:
      junit: test-results.xml
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

# ------------- Test Jobs -------------

test-python-3.10:
  <<: *test-template
  image: python:3.10

test-python-3.11:
  <<: *test-template
  image: python:3.11

test-python-3.12:
  <<: *test-template
  image: python:3.12

# ------------- Pre-commit Job -------------

pre-commit:
  stage: test
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install pre-commit
  script:
    - pre-commit run --all-files
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

coverage-report:
  stage: coverage
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install coverage[toml]
  script:
    - echo "Combining coverage reports from all Python versions"
    - coverage combine .coverage.*
    - coverage report --show-missing
    - coverage html
    - coverage xml
    - echo "Coverage report generated successfully"
  artifacts:
    when: always
    paths:
      - htmlcov/
      - coverage.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  needs:
    - test-python-3.10
    - test-python-3.11
    - test-python-3.12
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

publish_to_pypi:
  stage: publish
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install build twine
  script:
    # 1. Build the package with hatch
    - python -m build
    # 2. Publish to PyPI using twine with token authentication
    - python -m twine upload dist/* -u __token__ -p $PYPI_PASSWORD
  rules:
    # Only run on semantic version tags (v1.2.3 or 1.2.3)
    - if: '$CI_COMMIT_TAG =~ /^v?\d+\.\d+\.\d+/'
      protected: true
  artifacts:
    paths:
      - dist/
    expire_in: 1 day

publish_to_testpypi:
  stage: publish
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install build twine
  script:
    # 1. Build the package with hatch
    - python -m build
    # 2. Publish to TestPyPI using twine with token authentication
    - python -m twine upload dist/* -r testpypi -u __token__ -p $TESTPYPI_PASSWORD
  rules:
    - if: '$CI_COMMIT_TAG =~ /-rc|-a|-b|-alpha|-beta/'   # pre-releases
      protected: true
  artifacts:
    paths:
      - dist/
    expire_in: 1 day


# Base for release jobs (optional DRY)
.base_release: &base_release
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v?\d+\.\d+\.\d+/'

create-changelog:
  <<: *base_release
  stage: release
  image: registry.gitlab.com/gitlab-ci-utils/curl-jq:latest
  before_script:
    - apk add --no-cache git
  variables:
    CHANGELOG_BASE_URL: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/repository/changelog"
  script:
    # Fetch previous tag for incremental notes
    - PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

    # GET: Generate changelog notes from commit messages
    - |
      if [[ -n "$PREV_TAG" ]]; then
        echo "Generating incremental changelog from ${PREV_TAG} to ${CI_COMMIT_TAG}"
        curl -H "PRIVATE-TOKEN: ${CI_API_TOKEN}" \
             "${CHANGELOG_BASE_URL}?version=${CI_COMMIT_TAG}&from=${PREV_TAG}" | \
        jq -r '.notes' > release_notes.md
      else
        echo "Generating full changelog for ${CI_COMMIT_TAG}"
        curl -H "PRIVATE-TOKEN: ${CI_API_TOKEN}" \
             "${CHANGELOG_BASE_URL}?version=${CI_COMMIT_TAG}" | \
        jq -r '.notes' > release_notes.md
      fi

    # Verify release notes were generated
    - |
      if [[ -s release_notes.md ]]; then
        echo "✓ Release notes generated successfully"
        echo "---"
        cat release_notes.md
        echo "---"
      else
        echo "⚠ Warning: Release notes are empty. Using default message."
        echo "Release ${CI_COMMIT_TAG}" > release_notes.md
      fi
  artifacts:
    paths:
      - release_notes.md
    expire_in: 1 hour
  allow_failure: true  # Don't fail pipeline if changelog generation has issues

create-release-page:
  <<: *base_release
  stage: release
  needs:
    - job: create-changelog
      artifacts: true  # Pulls release_notes.md
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  script:
    - echo "Creating GitLab release page for version ${CI_COMMIT_TAG}"
  release:
    name: "Release ${CI_COMMIT_TAG}"
    description: release_notes.md  # Inserts the generated notes
    tag_name: ${CI_COMMIT_TAG}
    ref: ${CI_COMMIT_TAG}  # Simpler: points to the tag

docs_build_and_trigger_rtd:
  stage: publish
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install -e .[docs]
  script:
    # 1. Build the HTML documentation with MkDocs
    - mkdocs build -d site/
    # 2. Trigger Read the Docs webhook so it rebuilds instantly
    - curl -X POST -d "branches=main" -d "token=$RTD_WEBHOOK_TOKEN" \
           https://readthedocs.org/api/v2/webhook/${RTD_PROJECT_SLUG}/
  rules:
    # Run on every official release tag
    - if: '$CI_COMMIT_TAG =~ /^v?\d+\.\d+\.\d+/'
      protected: true
  artifacts:
    paths:
      - site/                 # mkdocs output folder
    expire_in: 1 day
